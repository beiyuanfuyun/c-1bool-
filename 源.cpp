//#define _CRT_SECURE_NO_WARNINGS
// 
// 
// -------bool类型------------------
//1.bool是一种数据类型
//2.取值为true（真1）或者false(假0)
//3.定义：bool isFind=false
//4.内存大小的1字节，char表示字符，而bool多表示真假
//---------------------------
//------应用场景-----------
//1.记录信息
//2.作为函数的分支开关，例如：升序，降序对应true,false
//3.作为函数的返回值，通知用户函数调用成功与否
//4.表示二进制
//------------------------------------

//-----------内联函数---------------
//内联函数和宏替换都是代码指令的替换，但是宏替换只是替换的文本，而内联函数的本质还是函数，有函数的对应特性
// 内联函数只是申请，而不一定会申请成功
// 换句话说就是，如果函数的内有循环或者递归，有或者代码量很大，那么这个申请就会失败，相当于普通函数
// 
// ---------引用-----------
// 引用的本质
// 引用实际上那个就是对一个变量或者对象起别名
// 引用在定义时必须初始化，且类型与被引用数据类型一致
// 对于一个变量的引用操作等同于操作的本身，操作的使用方法相同
// 引用传递：可以不用接引用，相当于本人过来了，可以直接更改
// --------------------------------------------------
//---------引用和取地址的区别，符号都是&-------
//带有类型的就是引用，否则就是取地址   int & a与  & a
// 
//---------引用和指针的区别----------------
// 指针是保存地址的变量，引用就是变量自己
//

//----------函数重载和参数的缺省
// 函数重载是指在同一个的项目中定义的函数名字可以重复使用
//也就是说可以有同名函数，但是要有条件才可以同名
// 可以将函数的功能集中与一个函数
//
// --------参数的缺省---------
// 在声明函数的某个参数的时候位置指定一个默认值
// 在调用该函数的时候如果采用的默认值
// 就无需指定该函数
//
//声明有缺省，定义时可以省略缺省
//void fun(int a = 33, int a2 = 99)
//#include<iostream>
//#include<string>

//#define ADD(x) x+x
//
//struct Stu
//{
//	char name[20];
//	int age;
//	bool sex;
//};
//
//
//inline int add(int x)
//{
//	return x + x;
//}

//int& setA(int& a)
//{
//	a = 6;
//	printf("内部的a=%d\n", a);
//	return a;//上面的int后面为什么要加上&，因为return a会备份消耗内存，不想备份直接使用int&不要备份
//	//当然c++不会对内存这么节约，例如inline就是浪费内存提升运行速率
//	//而且不要这样写
//	/*int aa = 8;
//	return aa;*/
//	//这样写会在vs的第二次使用时会报错，因为为临时的变量会随这函数的使用完毕而被释放
//}


//void fun(int a=66)
//{
//	printf("int   ");
//}
//void fun(int a , int a2 )
//{
//	printf("int 缺省%d  %d",a,a2);
//}
//void fun(int a, int a2,int)//站位参一般没有什么用处，除了构成重载
//{
//	printf("int   ");
//}
//void fun(double a)
//{
//	printf("double   ");
//}
//void fun(char a)
//{
//	printf("char   ");
//}
//int main()
//{
	//bool inFind = true;
	//printf("%d\n", inFind);
	//printf("%d\n", add(2));
	//int a = 1;
	//setA(a);
	//printf("外部的a=%d\n", a);

	/*int a = 1;
	int* pa = &a;
	int& aa = a;
	printf("a的地址\t\t%p\n", &a);
	printf("pa指向的地址\t%p\n",pa );
	printf("pa的地址\t%p\n", &pa);
	printf("aa的地址\t%p\n", &aa);*/

	/*int a1= 123;
	int a3 = 123;
	double a2 = 1.23;
	char a= '0';
	fun(a1);
	fun(a2);
	fun(a);
	fun(a1,a1,a1);*/
	//int a1 = 22;
	//fun();
	//fun(a1);//由于传参是从左往右进行的，那么缺省是从右往左进行的
		//这样编译器会疑惑，所以要删掉其中一个函数
	//return 0;
//}
//int main()
//{
//	fun();
//	return 0;
//}